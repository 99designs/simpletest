<?xml version="1.0"?>
<page title="Test runner documentation" here="Test runner">
    <long_title>SimpleTest for PHP test runner advanced documentation</long_title>
    <content>
        <section name="reporter" title="Selecting tests from the reporter">
            <p>
                The default action of SimpleTest is to run every test in
                the test suite.
                When refactoring, or before checking in new code, this is
                the type of behaviour you want.
                You cannot be sure you haven't broken something unless you
                run every test.
                Despite our best intentions to keep the test suite running
                quickly, there are some tests that will run slowly by
                their nature.
                When this happens we are faced with an unpleasant dilemma.
                We wait for the tests to run, breaking our flow, or we
                we run the tests less often.
                When we run the tests less often failures take longer
                to sort out, again breaking our flow.
            </p>
            <p>
                The most obvious solution is to run just the tests for the code
                we are working on, and then run the full test suite once the
                immediate work is complete.
                Here is a test script that reads just a single test file
                when it is entered into the URL...
<php><![CDATA[
<?php
    require_once('simpletest/unit_tester.php');
    require_once('simpletest/reporter.php');
    
    $test = &new GroupTest('My tests');<strong>
    if (isset($_GET['f'])) {
        $test->addTestFile($_GET['f']);    
    } else {
        $test->addTestFile('test_a.php');    
        $test->addTestFile('test_b.php');    
    }</strong>
    
    $test->run(HtmlReporter());
?>
]]></php>
                A brute force approach, but effective nevertheless.
            </p>
            <p>
                The simplest approach to running just a single test case is
                to load only that test case in the top level test script...
<php><![CDATA[
<?php
    require_once('simpletest/unit_tester.php');
    require_once('simpletest/reporter.php');
    
    $test = &new GroupTest('My tests');
    if (isset($_GET['f'])) {<strong>
        if (isset($_GET['c'])) {
            $test->addTestFile($_GET['f'], array($_GET['c']));
        } else {
            $test->addTestFile($_GET['f']);    
        }</strong>
    } else {
        $test->addTestFile('test_a.php');    
        $test->addTestFile('test_b.php');    
    }
    
    $test->run(HtmlReporter());
?>
]]></php>
                This is OK if you want to run a whole test case, but not
                if you only want to run part of a test case because a single
                test method is causing particular difficulty.
                To work around this, the <code>SimpleReporter</code>
                has the option to run only particular test methods.
                Here is a Reporter subclass that only runs a single test
                method...
<php><![CDATA[<strong>
class OneTestReporter extends HtmlReporter {
    var $_just_this;
    
    function OneTestReporter($just_this, $encoding = 'ISO-8859-1') {
        $this->_just_this = $just_this;
        $this->HtmlReporter($encoding);
    }
    
    function invoke(&$runner, $method) {
        if (strtolower($method) == strtolower($this->_just_this)) {
            parent::invoke($runner, $method);
        }
    }
}</strong>
]]></php>
                It's then pretty straight forward to adjust the top level
                test script to select a single test...
<php><![CDATA[
<?php
    require_once('simpletest/unit_tester.php');
    require_once('one_test_reporter.php');
    
    $test = &new GroupTest('My tests');
    if (isset($_GET['f'])) {
        if (isset($_GET['c'])) {
            $test->addTestFile($_GET['f'], array($_GET['c']));
        } else {
            $test->addTestFile($_GET['f']);
        }
    } else {
        $test->addTestFile('test_a.php');    
        $test->addTestFile('test_b.php');    
    }
    <strong>
    if (isset($_GET['t'])) {
        $reporter = &new OneTestReporter($_GET['t']);
    } else {
        $reporter = &new HtmlReporter();
    }
    $test->run($reporter);</strong>
?>
]]></php>
                Our script is now rather messy, so it's probably time to
                think about building some kind of test UI class just to tidy
                things up.
            </p>
            <p>
                You shouldn't need these tricks too often though.
                If you have slow tests your priority should be to find
                ways of speeding them up.
                This may mean mocking out problematic resources and moving
                the lower level tests for these into separate test suites.
                Hopefully there is a refactoring that allows the less stressed
                areas of the application to run in their own separate test group.
            </p>
            <p>
                It may also mean that a full test run can only be run on a separate
                server.
                This technique is known as &quot;nightly builds&quot; when run overnight
                and &quot;continuous integration&quot; when done after every check-in.
            </p>
        </section>
        <section name="runner" title="How the test cases run themselves">
            <p>
                The test cases do not actually call methods on themselves
                Instead they spawn a runner object to do it for them and
                the factory for this runner can be overridden for various
                effects.
            </p>
            <p>
                First, here is the signature for the runner...
<php><![CDATA[
class SimpleRunner {
    function SimpleRunner(&$test_case, &$scorer) { }
    function &getTestCase() { }
    function run() { }<strong>
    function _isTest($method) { }
    function invoke($method) { }</strong>
    function paintMethodStart($test_name) { }
    function paintMethodEnd($test_name) { }
    function paintPass($message) { }
    function paintFail($message) { }
    function paintError($message) { }
    function paintException($exception) { }
    function paintMessage($message) { }
    function paintFormattedMessage($message) { }
    function paintSignal($type, &$payload) { }
}
]]></php>
                The key flex point is the <code>invoke()</code> method.
                You can use this to change or embellish the run time behaviour
                of the test case.
                The paint methods are intercepts of the messages on their way
                to the reporter and the <code>_isTest()</code> method is
                used to decide which methods are test methods.
            </p>
            <p>
                The default runner for <code>UnitTestCase</code> is not
                <code>SimpleRunner</code>, but <code>SimpleErrorTrappingRunner</code>.
                This subclass adds the SimpleTest error trap so that
                the <code>UnitTestCase::assertError()</code> methods work
                correctly.
                This means that if you want to turn the error trapping behaviour
                off, perhaps it interferes with your debugger, you can do
                so by having the test case create the more primitive
                <code>SimpleRunner</code>...
<php><![CDATA[
class MyTest extends UnitTestCase {
    
    function &_createRunner(&$reporter) {
        return new SimpleRunner($this, $reporter);
    }
}
]]></php>
                This means that errors will now halt the test suite if encountered
                in this test case.
            </p>
            <p>
                For a more interesting example we can take a leaf out of
                <a href="http://jbehave.codehaus.org/">JBehave</a>'s
                book by making our test methods start with the prefix
                "should" rather than "test".
                Although less usual, this makes the test names more
                readable.
<php><![CDATA[
class JBehaveStyleRunner extends SimpleRunner {
    function JBehaveStyleRunner(&$test_case, &$scorer) {
        $this->SimpleRunner($test_case, $scorer);
    }
    
    function _isTest($method) {
        return strtolower(substr($method, 0, 6)) == 'should';
    }
}
]]></php>
                All we have done is to override the name check so that
                it returns true if the method name starts with "should".
                We can test that it works with the following test case...
<php><![CDATA[
class TestOfJBehaveStyleRunner extends UnitTestCase {
    
    function &_createRunner(&$reporter) {
        return new JBehaveStyleRunner($this, $reporter);
    }
    
    function testShouldNotBeRun() {
        $this->fail('Starts with test');
    }
    
    function shouldBeRun() {
        $this->pass('Starts with should');
    }
}
]]></php>
                It's a matter of taste which you prefer.
            </p>
        </section>
    </content>
    <internal>
        <link>
            Selecting tests from <a href="#reporter">the reporter</a>
        </link>
        <link>
            How the <a href="#runner">test cases run</a>
        </link>
    </internal>
    <external>
        <link>
            SimpleTest project page on <a href="http://sourceforge.net/projects/simpletest/">SourceForge</a>.
        </link>
        <link>
            SimpleTest download page on <a href="http://www.lastcraft.com/simple_test.php">LastCraft</a>.
        </link>
        <link>
            The <a href="http://simpletest.sourceforge.net/">developer&apos;s API for SimpleTest</a>
            gives full detail on the classes and assertions available.
        </link>
    </external>
    <meta>
        <keywords>
            php unit testing,
            documentation,
            test runner,
            controller,
            MVC pattern,
            marcus baker,
            simple test,
            simpletest,
            remote testing,
            extreme programming tests,
            automated testing
        </keywords>
    </meta>
</page>