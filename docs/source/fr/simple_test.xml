<?xml version="1.0" encoding="ISO-8859-1" ?>
<page title="Prise en main rapide de SimpleTest" here="Prise en main rapide de SimpleTest">
    <long_title>
        Prise en main rapide de SimpleTest pour PHP - Tests unitaire et objets fantaisie pour PHP
    </long_title>
    <content>
        <introduction>
            <p>
                Le présent article présuppose que vous soyez familier avec le concept de tests unitaires ainsi que celui de développement web avec le langage PHP. Il s'agit d'un guide pour le nouvel et impatient utilisateur de <a href="https://sourceforge.net/project/showfiles.php?group_id=76550">SimpleTest</a>. Pour une documentation plus complète, particulièrement si vous découvrez les tests unitaires, consultez la <a href="http://www.lastcraft.com/unit_test_documentation.php">documentation en cours</a>, et pour des exemples de scénarios de test, consultez le <a href="http://www.lastcraft.com/first_test_tutorial.php">tutorial sur les tests unitaires</a>.
            </p>
        </introduction>
        <section name="unit" title="Utiliser le testeur rapidement">
            <p>
                Parmi les outils de test pour logiciel, le testeur unitaire est le plus proche du développeur. Dans un contexte de développement agile, le code de test se place juste à côté du code source étant donné que tous les deux sont écrits simultanément. Dans ce contexte, SimpleTest aspire à être une solution complète de test pour un développeur PHP et s'appelle "Simple" parce qu'elle devrait être simple à utiliser et à étendre. Ce nom n'était pas vraiment un bon choix. Non seulement cette solution inclut toutes les fonctions classiques qu'on est en droit d'attendre de la part des portages de <a href="http://www.junit.org/">JUnit</a> et des <a href="http://sourceforge.net/projects/phpunit/">PHPUnit</a>, mais elle inclut aussi les <a href="http://www.mockobjects.com/">objets fantaisie ou &quot;mock objects&quot;</a>. Sans compter quelques fonctionnalités de <a href="http://sourceforge.net/projects/jwebunit/">JWebUnit</a> : parmi celles-ci la navigation sur des pages web, les tests sur les cookies et l'envoi de formulaire.
            </p>
            <p>
                La démonstration la plus rapide : l'exemple
            </p>
            <p>
                Supposons que nous sommes en train de tester une simple classe de log dans un fichier : elle s'appelle <code>Log</code> dans <em>classes/Log.php</em>. Commençons par créer un script de test, appelé <em>tests/log_test.php</em>. Son contenu est le suivant...
<php><![CDATA[
<strong><?php
require_once('simpletest/unit_tester.php');
require_once('simpletest/reporter.php');
require_once('../classes/log.php');
?></strong>
]]></php>
                Ici le répertoire <em>simpletest</em> est soit dans le dossier courant, soit dans les dossiers pour fichiers inclus. Vous auriez à éditer ces arborescences suivant l'endroit où vous avez installé SimpleTest. Ensuite créons un scénario de test...
<php><![CDATA[
<?php
require_once('simpletest/unit_tester.php');
require_once('simpletest/reporter.php');
require_once('../classes/log.php');
<strong>
class TestOfLogging extends UnitTestCase {
}</strong>
?>
]]></php>
                A présent il y a 5 lignes de code d'échafaudage et toujours pas de test. Cependant à partir de cet instant le retour sur investissement arrive très rapidement. Supposons que la classe <code>Log</code> prenne le nom du fichier à écrire dans le constructeur et que nous ayons un répertoire temporaire dans lequel placer ce fichier...
<php><![CDATA[
<?php
require_once('simpletest/unit_tester.php');
require_once('simpletest/reporter.php');
require_once('../classes/log.php');

class TestOfLogging extends UnitTestCase {
    <strong>
    function testCreatingNewFile() {
        @unlink('/temp/test.log');
        $log = new Log('/temp/test.log');
        $this->assertFalse(file_exists('/temp/test.log'));
        $log->message('Should write this to a file');
        $this->assertTrue(file_exists('/temp/test.log'));
    }</strong>
}
?>
]]></php>
                Au lancement du scénario de test, toutes les méthodes qui commencent avec la chaîne <code>test</code> sont identifiées puis exécutées. D'ordinaire nous avons bien plusieurs méthodes de tests. Les assertions dans les méthodes de test envoient des messages vers le framework de test qui affiche immédiatement le résultat. Cette réponse immédiate est importante, non seulement lors d'un crash causé par le code, mais aussi de manière à rapprocher l'affichage de l'erreur au plus près du scénario de test concerné.
            </p>
            <p>
                Pour voir ces résultats lançons effectivement les tests. S'il s'agit de l'unique scénario de test à lancer, on peut y arriver avec...
<php><![CDATA[
<?php
require_once('simpletest/unit_tester.php');
require_once('simpletest/reporter.php');
require_once('../classes/log.php');

class TestOfLogging extends UnitTestCase {
    
    function testCreatingNewFile() {
        @unlink('/temp/test.log');
        $log = new Log('/temp/test.log');
        $this->assertFalse(file_exists('/temp/test.log'));
        $log->message('Should write this to a file');
        $this->assertTrue(file_exists('/temp/test.log'));
    }
}
<strong>
$test = &new TestOfLogging();
$test->run(new HtmlReporter());</strong>
?>
]]></php>
            </p>
            <p>
                En cas échec, l'affichage ressemble à...
                <div class="demo">
                    <h1>testoflogging</h1>
                    <span class="fail">Fail</span>: testcreatingnewfile-&gt;True assertion failed.<br />
                    <div style="padding: 8px; margin-top: 1em; background-color: red; color: white;">1/1 test cases complete.
                    <strong>1</strong> passes and <strong>1</strong> fails.</div>
                </div>
                ...et si ça passe, on obtient...
                <div class="demo">
                    <h1>testoflogging</h1>
                    <div style="padding: 8px; margin-top: 1em; background-color: green; color: white;">1/1 test cases complete.
                    <strong>2</strong> passes and <strong>0</strong> fails.</div>
                </div>
				Et si vous obtenez ça...
                <div class="demo">
                    <b>Fatal error</b>:  Failed opening required '../classes/log.php' (include_path='') in <b>/home/marcus/projects/lastcraft/tutorial_tests/Log/tests/log_test.php</b> on line <b>7</b>
                </div>
				c'est qu'il vous manque le fichier <em>classes/Log.php</em> qui pourrait ressembler à : 
<php><![CDATA[
<?php
class Log {
    
        function Log($file_path) {
        }
}
?>;
]]></php>
            </p>
        </section>
        <section name="group" title="Construire des groupes de tests">
            <p>
                Il est peu probable que dans une véritable application on ait uniquement besoin de passer un seul scénario de test. Cela veut dire que nous avons besoin de grouper les scénarios dans un script de test qui peut, si nécessaire, lancer tous les tests de l'application.
            </p>
            <p>
                Notre première étape est de supprimer les includes et de défaire notre hack précédent...
<php><![CDATA[
<?php<strong>
require_once('../classes/log.php');</strong>

class TestOfLogging extends UnitTestCase {
    
    function testCreatingNewFile() {
        @unlink('/temp/test.log');
        $log = new Log('/temp/test.log');
        $this->assertFalse(file_exists('/temp/test.log'));
        $log->message('Should write this to a file');
        $this->assertTrue(file_exists('/temp/test.log'));<strong>
    }
}
?></strong>
]]></php>
                Ensuite nous créons un nouveau fichier appelé <em>tests/all_tests.php</em>. On y insère le code suivant...
<php><![CDATA[
<strong><?php
require_once('simpletest/unit_tester.php');
require_once('simpletest/reporter.php');

$test = &new GroupTest('All tests');
$test->addTestFile('log_test.php');
$test->run(new HtmlReporter());
?></strong>
]]></php>
                Cette méthode <code>GroupTest::addTestFile()</code> va inclure le fichier de scénarios de test et lire parmi toutes les nouvelles classes créées celles qui sont issues de <code>TestCase</code>. Dans un premier temps, seuls les noms sont stockés, de la sorte le lanceur de test peut instancier la classe au fur et à mesure qu'il exécute votre suite de tests.
            </p>
            <p>
                Pour que ça puisse marcher proprement le fichier de suite de tests ne devrait pas inclure aveuglement d'autres extensions de scénarios de test qui n'exécuteraient pas effectivement de test. Le résultat pourrait être que des tests supplémentaires soient alors comptabilisés pendant l'exécution des tests. Ce n'est pas un problème grave mais pour éviter ce désagrément, il suffit d'ajouter la commande <code>SimpleTestOptions::ignore()</code> quelque part dans le fichier de scénario de test. Par ailleurs le scénario de test ne devrait pas avoir été inclus ailleurs ou alors aucun scénario ne sera ajouté aux groupes de test. Il s'agirait là d'une erreur autrement sérieuse : si toutes les classes de scénario de test sont chargées par PHP, alors la méthode <code>GroupTest::addTestFile()</code> ne pourra pas les détecter.
            </p>
            <p>
                Pour afficher les résultats, il est seulement nécessaire d'invoquer <em>tests/all_tests.php</em> à partir du serveur web.
            </p>
        </section>
        <section name="mock" title="Utiliser les objets fantaisie">
            <p>
                Avançons un peu plus dans le futur.
            </p>
            <p>
                Supposons que notre class logging soit testée et terminée. Supposons aussi que nous testons une autre classe qui ait besoin d'écrire des messages de log, disons <code>SessionPool</code>. Nous voulons tester une méthode qui ressemblera probablement à quelque chose comme...
<php><![CDATA[<strong>
class SessionPool {
    ...
    function logIn($username) {
        ...
        $this->_log->message('User $username logged in.');
        ...
    }
    ...
}
</strong>
]]></php>
                Avec le concept de "réutilisation de code" comme fil conducteur, nous utilisons notre class <code>Log</code>. Un scénario de test classique ressemblera peut-être à...
<php><![CDATA[<strong>
<?php
require_once('../classes/log.php');
require_once('../classes/session_pool.php');

class TestOfSessionLogging extends UnitTestCase {
    
    function setUp() {
        @unlink('/temp/test.log');
    }
    
    function tearDown() {
        @unlink('/temp/test.log');
    }
    
    function testLogInIsLogged() {
        $log = new Log('/temp/test.log');
        $session_pool = &new SessionPool($log);
        $session_pool->logIn('fred');
        $messages = file('/temp/test.log');
        $this->assertEqual($messages[0], "User fred logged in.\n");
    }
}
?></strong>
]]></php>
                Le design de ce scénario de test n'est pas complètement mauvais, mais on peut l'améliorer. Nous passons du temps à tripoter les fichiers de log qui ne font pas partie de notre test. Pire, nous avons créé des liens de proximité entre la classe <code>Log</code> et ce test. Que se passerait-il si nous n'utilisions plus de fichiers, mais la bibliothèque <em>syslog</em> à la place ? Avez-vous remarqué le retour chariot supplémentaire à la fin du message ? A-t-il été ajouté par le loggueur ? Et si il ajoutait aussi un timestamp ou d'autres données ?
            </p>
            <p>
                L'unique partie à tester réellement est l'envoi d'un message précis au loggueur. Nous réduisons le couplage en créant une fausse classe de logging : elle ne fait qu'enregistrer le message pour le test, mais ne produit aucun résultat. Sauf qu'elle doit ressembler exactement à l'original.
            </p>
            <p>
                Si l'objet fantaisie n'écrit pas dans un fichier alors nous nous épargnons la suppression du fichier avant et après le test. Nous pourrions même nous épargner quelques lignes de code supplémentaires si l'objet fantaisie pouvait exécuter l'assertion.
            <p>
            </p>
                Trop beau pour être vrai ? Par chance on peut créer un tel objet très facilement...
<php><![CDATA[
<?php
require_once('../classes/log.php');
require_once('../classes/session_pool.php');<strong>
Mock::generate('Log');</strong>

class TestOfSessionLogging extends UnitTestCase {
    
    function testLogInIsLogged() {<strong>
        $log = &new MockLog($this);
        $log->expectOnce('message', array('User fred logged in.'));</strong>
        $session_pool = &new SessionPool($log);
        $session_pool->logIn('fred');<strong>
        $log->tally();</strong>
    }
}
?>
]]></php>
                L'appel <code>tally()</code> est nécessaire pour annoncer à l'objet fantaisie qu'il n'y aura plus d'appels ultérieurs. Sans ça l'objet fantaisie pourrait attendre pendant une éternité l'appel de la méthode sans jamais prévenir le scénario de test. Les autres tests sont déclenchés automatiquement quand l'appel à <code>message()</code> est invoqué sur l'objet <code>MockLog</code>. L'appel <code>mock</code> va déclencher une comparaison des paramètres et ensuite envoyer le message "pass" ou "fail" au test pour l'affichage. Des jokers peuvent être inclus ici aussi afin d'empêcher que les tests ne deviennent trop spécifiques.
            </p>
            <p>
                Les objets fantaisie dans la suite SimpleTest peuvent avoir un ensemble de valeurs de sortie arbitraires, des séquences de sorties, des valeurs de sortie sélectionnées à partir des arguments d'entrée, des séquences de paramètres attendus et des limites sur le nombre de fois qu'une méthode peut être invoquée.
            </p>
            <p>
                Pour que ce test fonctionne la librairie avec les objets fantaisie doit être incluse dans la suite de tests, par exemple dans <em>all_tests.php</em>.
            </p>
        </section>
        <section name="web" title="Tester une page web">
            <p>
                Une des exigences des sites web, c'est qu'ils produisent des pages web. Si vous construisez un projet de A à Z et que vous voulez intégrer des tests au fur et à mesure alors vous voulez un outil qui puisse effectuer une navigation automatique et en examiner le résultat. C'est le boulot d'un testeur web.
            </p>
            <p>
                Effectuer un test web via SimpleTest reste assez primitif : il n'y a pas de javascript par exemple. Pour vous donner une idée, voici un exemple assez trivial : aller chercher une page web, à partir de là naviguer vers la page "about" et finalement tester un contenu déterminé par le client.
<php><![CDATA[
<?php<strong>
require_once('simpletest/web_tester.php');</strong>
require_once('simpletest/reporter.php');
<strong>
class TestOfAbout extends WebTestCase {
    
    function setUp() {
        $this->get('http://test-server/index.php');
        $this->clickLink('About');
    }
    
    function testSearchEngineOptimisations() {
        $this->assertTitle('A long title about us for search engines');
        $this->assertWantedPattern('/a popular keyphrase/i');
    }
}</strong>
$test = &new TestOfAbout();
$test->run(new HtmlReporter());
?>
]]></php>
                Avec ce code comme test de recette, vous pouvez vous assurer que le contenu corresponde toujours aux spécifications à la fois des développeurs et des autres parties prenantes au projet.
            </p>
            <p>
                <a href="http://sourceforge.net/projects/simpletest/"><img src="http://sourceforge.net/sflogo.php?group_id=76550&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo"/></a>
            </p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#unit">Utiliser le testeur rapidement</a>
            avec un exemple.
        </link>
        <link>
            <a href="#group">Groupes de tests</a>
            pour tester en un seul clic.
        </link>
        <link>
            <a href="#mock">Utiliser les objets fantaisie</a>
            pour faciliter les tests et gagner en contrôle.
        </link>
        <link>
            <a href="#web">Tester des pages web</a>
            au niveau de l'HTML.
        </link>
    </internal>
    <external>
        <link>
            <a href="https://sourceforge.net/project/showfiles.php?group_id=76550&amp;release_id=153280">Télécharger PHP Simple Test</a>
            depuis <a href="http://sourceforge.net/projects/simpletest/">SourceForge</a>.
        </link>
        <link>
            L'<a href="http://simpletest.sourceforge.net/">API de SimpleTest pour développeur</a>
            donne tous les détails sur les classes et assertions existantes.
        </link>
    </external>
    <meta>
        <keywords>
            développement logiciel,
            programmation php,
            outils de développement logiciel,
            tutorial php,
            scripts php gratuits,
            architecture,
            ressources php,
            objets fantaise,
            junit,
            php testing,
            php unit,
            méthodologie,
            développement piloté par les tests,
            sourceforge,
            open source,
            unit test,
            web tester,
            web testing,
            outils tests html,
            tester des web pages,
            php objets fantaise,
            naviguer automatiquement sur des sites web,
            test automatisé,
            scripting web,
            wget,
            test curl,
            jmock pour php,
            jwebunit,
            phpunit,
            php unit testing,
            php web testing,
            jason sweat,
            marcus baker,
            perrick penet,
            topstyle plug in,
            phpedit plug in
        </keywords>
    </meta>
</page>
