<?xml version="1.0"?>
<page title="Server stubs documentation" here="Server stubs">
    <long_title>SimpleTest for PHP server stubs documentation</long_title>
    <content>
        <section name="what" title="What are server stubs?">
            <p>
                This was originally a pattern named by Robert Binder (Testing
                object-oriented systems: models, patterns, and tools,
                Addison-Wesley) in 1999.
                A server stub is a simulation of an object or component.
                It should exactly replace a component in a system for test
                or prototyping purposes, but remain lightweight.
                This allows tests to run more quickly, or if the simulated
                class has not been written, to run at all.
            </p>
        </section>
        <section name="creation" title="Creating server stubs">
            <p>
                All we need is an existing class, say a database connection
                that looks like this...
<php><![CDATA[
<strong>class DatabaseConnection {
    function DatabaseConnection() {
    }
    
    function query() {
    }
    
    function selectQuery() {
    }
}</strong>
]]></php>
                The class does not need to have been implemented yet.
                To create a stub version of the class we need to include the
                server stub library and run the generator...
<php><![CDATA[
<strong>require_once('simpletest/mock_objects.php');
require_once('database_connection.php');
Stub::generate('DatabaseConnection');</strong>
]]></php>
                This generates a clone class called
                <code>StubDatabaseConnection</code>.
                We can now create instances of the new class within
                our prototype script...
<php><![CDATA[
require_once('simpletest/mock_objects.php');
require_once('database_connection.php');
Stub::generate('DatabaseConnection');
<strong>
$connection = new StubDatabaseConnection();
</strong>
]]></php>
                The stub version of a class has all the methods of the original
                so that operations like
                <code><![CDATA[$connection->query()]]></code> are still
                legal.
                The return value will be <code>null</code>,
                but we can change that with...
<php><![CDATA[
<strong>$connection->setReturnValue('query', 37)</strong>
]]></php>
                Now every time we call
                <code><![CDATA[$connection->query()]]></code> we get
                the result of 37.
                We can set the return value to anything, say a hash of
                imaginary database results or a list of persistent objects.
                Parameters are irrelevant here, we always get the same
                values back each time once they have been set up this way.
                That may not sound like a convincing replica of a
                database connection, but for the half a dozen lines of
                a test method it is usually all you need.
            </p>
        </section>
        <section name="patterns" title="Simulation patterns">
            <p>
                Things aren&apos;t always that simple though.
                One common problem is iterators, where constantly returning
                the same value could cause an endless loop in the object
                being tested.
                For these we need to set up sequences of values.
                Let&apos;s say we have a simple iterator that looks like this...
<php><![CDATA[
class Iterator {
    function Iterator() {
    }
    
    function next() {
    }
}
]]></php>
                This is about the simplest iterator you could have.
                Assuming that this iterator only returns text until it
                reaches the end, when it returns false, we can simulate it
                with...
<php><![CDATA[
<strong>Stub::generate('Iterator');

$iterator = new StubIterator();
$iterator->setReturnValue('next', false);
$iterator->setReturnValueAt(0, 'next', 'First string');
$iterator->setReturnValueAt(1, 'next', 'Second string');</strong>
]]></php>
                When <code>next()</code> is called on the
                stub iterator it will first return &quot;First string&quot;,
                on the second call &quot;Second string&quot; will be returned
                and on any other call <code>false</code> will
                be returned.
                The sequenced return values take precedence over the constant
                return value.
                The constant one is a kind of default if you like.
            </p>
            <p>
                Another tricky situation is an overloaded
                <code>get()</code> operation.
                An example of this is an information holder with name/value pairs.
                Say we have a configuration class like...
<php><![CDATA[
class Configuration {
    function Configuration() {
    }
    
    function getValue($key) {
    }
}
]]></php>
                This is a classic situation for using stub objects as
                actual configuration will vary from machine to machine,
                hardly helping the reliability of our tests if we use it
                directly.
                The problem though is that all the data comes through the
                <code>getValue()</code> method and yet
                we want different results for different keys.
                Luckily the stubs have a filter system...
<php><![CDATA[
<strong>Stub::generate('Configuration');

$config = &new StubConfiguration();
$config->setReturnValue('getValue', 'primary', array('db_host'));
$config->setReturnValue('getValue', 'admin', array('db_user'));
$config->setReturnValue('getValue', 'secret', array('db_password'));</strong>
]]></php>
                The extra parameter is a list of arguments to attempt
                to match.
                In this case we are trying to match only one argument which
                is the look up key.
                Now when the server stub has the
                <code>getValue()</code> method invoked
                like this...
<php><![CDATA[
$config->getValue('db_user');
]]></php>
                ...it will return &quot;admin&quot;.
                It finds this by attempting to match the calling arguments
                to its list of returns one after another until
                a complete match is found.
            </p>
            <p>
                You can set a default argument argument like so...
<php><![CDATA[<strong>
$config->setReturnValue('getValue', false, array('*'));</strong>
]]></php>
                This is not the same as setting the return value without
                any argument requirements like this...
<php><![CDATA[<strong>
$config->setReturnValue('getValue', false);</strong>
]]></php>
                In the first case it will accept any single argument,
                but exactly one is required.
                In the second case any number of arguments will do and
                it acts as a catchall after all other matches.
                Note that if we add further single parameter options after
                the wildcard in the first case, they will be ignored as the wildcard
                will match first.
                With complex parameter lists the ordering could be important
                or else desired matches could be masked by earlier wildcard
                ones.
                Declare the most specific matches first if you are not sure.
            </p>
            <p>
                There are times when you want a specific object to be
                dished out by the stub rather than just a copy.
                The PHP copy semantics force us to use a different method
                for this.
                You might be simulating a container for example...
<php><![CDATA[
class Thing {
}

class Vector {
    function Vector() {
    }
    
    function get($index) {
    }
}
]]></php>
                In this case you can set a reference into the stub&apos;s
                return list...
<php><![CDATA[
Stub::generate('Vector');

$thing = new Thing();<strong>
$vector = &new StubVector();
$vector->setReturnReference('get', $thing, array(12));</strong>
]]></php>
                With this arrangement you know that every time
                <code><![CDATA[$vector->get(12)]]></code> is
                called it will return the same
                <code>$thing</code> each time.
            </p>
            <p>
                These three factors, timing, parameters and whether to copy,
                can be combined orthogonally.
                For example...
<php><![CDATA[
$complex = &new StubComplexThing();
$stuff = new Stuff();<strong>
$complex->setReturnReferenceAt(3, 'get', $stuff, array('*', 1));</strong>
]]></php>
                This will return the <code>$stuff</code> only on the third
                call and only if two parameters were set the second of
                which must be the integer 1.
                That should cover most simple prototyping situations.
            </p>
            <p>
                A final tricky case is one object creating another, known
                as a factory pattern.
                Suppose that on a successful query to our imaginary
                database, a result set is returned as an iterator with
                each call to <code>next()</code> giving
                one row until false.
                This sounds like a simulation nightmare, but in fact it can all
                be stubbed using the mechanics above.
            </p>
            <p>
                Here&apos;s how...
<php><![CDATA[
Stub::generate('DatabaseConnection');
Stub::generate('ResultIterator');

class DatabaseTest extends UnitTestCase {
    
    function testUserFinder() {<strong>
        $result = &new StubResultIterator();
        $result->setReturnValue('next', false);
        $result->setReturnValueAt(0, 'next', array(1, 'tom'));
        $result->setReturnValueAt(1, 'next', array(3, 'dick'));
        $result->setReturnValueAt(2, 'next', array(6, 'harry'));
        
        $connection = &new StubDatabaseConnection();
        $connection->setReturnValue('query', false);
        $connection->setReturnReference(
                'query',
                $result,
                array('select id, name from users'));</strong>
                
        $finder = &new UserFinder($connection);
        $this->assertIdentical(
                $finder->findNames(),
                array('tom', 'dick', 'harry'));
    }
}
]]></php>
                Now only if our
                <code>$connection</code> is called with the correct
                <code>query()</code> will the
                <code>$result</code> be returned that is
                itself exhausted after the third call to <code>next()</code>.
                This should be enough
                information for our <code>UserFinder</code> class,
                the class actually
                being tested here, to come up with goods.
                A very precise test and not a real database in sight.
            </p>
        </section>
        <section name="options" title="Stub creation options">
            <p>
                There are some additional options when creating stubs.
                At the generation stage we can change the class name...
<php><![CDATA[
<strong>Stub::generate('Iterator', 'MyStubIterator');
$iterator = &new MyStubIterator();
</strong>
]]></php>
                This is not very useful in itself as there would be no difference
                in this class and the default except for the name.
                However we can also add additional methods not found in the
                original interface...
<php><![CDATA[
class Iterator {
}
<strong>Stub::generate('Iterator', 'PrototypeIterator', array('next', 'isError'));
$iterator = &new PrototypeIterator();
$iterator->setReturnValue('next', 0);
</strong>
]]></php>
                The <code>next()</code> and
                <code>isError()</code> methods can now have
                return values set just as if they existed in the original class.
            </p>
            <p>
                One other esoteric way of customising the stubs is to change
                the default wildcard used for parameter matching.
<php><![CDATA[
<strong>Stub::generate('Connection');
$iterator = &new StubConnection('wild');
$iterator->setReturnValue('query', array('id' => 33), array('wild'));
</strong>
]]></php>
                The only reason to do this is if you genuinely wanted to test
                against the literal string &quot;*&quot; and didn&apos;t want it
                interpreted as &quot;any&quot;.
            </p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#what">What are server stubs?</a>
        </link>
        <link>
            <a href="#creation">Creating server stubs</a> with SimpleTest.
        </link>
        <link>
            <a href="#patterns">Patterns of simulation</a> for faking
            more complex object interactions.
        </link>
        <link>
            <a href="#options">Generation options</a> for different
            contexts.
        </link>
    </internal>
    <external>
        <link>
            SimpleTest project page on <a href="http://sourceforge.net/projects/simpletest/">SourceForge</a>.
        </link>
        <link>
            SimpleTest download page on <a href="http://www.lastcraft.com/simple_test.php">LastCraft</a>.
        </link>
        <link>
            <a href="http://simpletest.sourceforge.net/">Full API for SimpleTest</a>
            from the PHPDoc.
        </link>
    </external>
    <meta>
        <keywords>
            software development,
            php programming,
            programming php,
            software development tools,
            php tutorial,
            free php test tool,
            architecture,
            php resources,
            mock objects,
            prototyping with scripting languages,
            server stubs,
            unit test,
            php prototyping,
            test methods,
            testing methodology
        </keywords>
    </meta>
</page>