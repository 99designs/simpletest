<refentry id="{@id}">
  <refnamediv>
    <refname>Unit Test Cases</refname>
    <refpurpose>The core system is a regression testing framework built around test cases.</refpurpose>
  </refnamediv>
  {@toc}
  
  <refsect1 id="{@id overview}">
    <title>Unit Test Case</title>
    <para>A sample test case looks like this...</para>
    <para>
     <programlisting role="php">
     <![CDATA[
class FileTestCase extends UnitTestCase {
    function FileTestCase() {
        $this->UnitTestCase('File test');
    }
}     
     ]]>
     </programlisting>
    </para>
    <para>
    If no test name is supplied whe chaining the constructor then the class name will be taken instead. This will be the name displayed in the test results.
    </para>
    <para>
    Actual tests are added as methods in the test case whose names start with the string "test" and when the test case is invoked all such methods are run in the random order that PHP introspection finds them. As many test methods can be added as needed. For example...
    </para>
    <para>
     <programlisting role="php">
     <![CDATA[
require_once('../classes/writer.php');

class FileTestCase extends UnitTestCase {
    function FileTestCase() {
        $this->UnitTestCase('File test');
    }
    function setUp() {
        @unlink('../temp/test.txt');
    }
    function tearDown() {
        @unlink('../temp/test.txt');
    }
    function testCreation() {
        $writer = &new FileWriter('../temp/test.txt');
        $writer->write('Hello');
        $this->assertTrue(file_exists('../temp/test.txt'), 'File created');
    }
}     
     ]]>
     </programlisting>
    </para>
    <para>
    Our only test method at the moment is <command>testCreation()</command> where we check that a file has been created by our <command>Writer</command> object. We could have put the <command>unlink()</command> code into this method as well, but by placing it in <command>setUp()</command> and <command>tearDown()</command> we can use it with other test methods that we add.
    </para>
    <para>
    The <command>setUp()</command> method is run just befor every test method. <command>tearDown()</command> is run just after every test method. You can place some test case set up into the constructor to be run once for all the cases in the test, but you risk test inteference that way. This way is slightly slower, but it is safer.
    </para>
    <para>
    The means of reporting test results (see below) are by attached observers that are notified by various <command>assert...()</command> methods. Here is the full list for the <command>UnitTestCase</command> class, the default for SimpleTest...
    </para>
    <para>
    <table frame="all" id="{@id asserttab}">
      <tgroup cols="2">
        <tbody>
        <row>
          <entry>assertTrue($x)</entry>
          <entry>Fail if $x is false</entry>
        </row>
        <row>
	  <entry>assertFalse($x)</entry>
	  <entry>Fail if $x is true</entry>
        </row>
        <row>
          <entry>assertNull($x)</entry>
          <entry>Fail if $x is set</entry>
        </row>
        <row>
          <entry>assertNotNull($x)</entry>
          <entry>Fail if $x not set</entry>
        </row>
        <row>
          <entry>assertIsA($x, $t)</entry>
          <entry>Fail if $x is not the class or type $t</entry>
        </row>
        <row>
          <entry>assertEqual($x, $y)</entry>
          <entry>Fail if $x == $y is false</entry>
        </row>
        <row>
          <entry>assertNotEqual($x, $y)</entry>
          <entry>Fail if $x == $y is true</entry>
        </row>
        <row>
          <entry>assertIdentical($x, $y)</entry>
          <entry>Fail if $x === $y is false</entry>
        </row>
        <row>
          <entry>assertNotIdentical($x, $y)</entry>
          <entry>Fail if $x === $y is true</entry>
        </row>
        <row>
          <entry>assertReference($x, $y)</entry>
          <entry>Fail unless $x and $y are the same variable</entry>
        </row>
        <row>
          <entry>assertCopy($x, $y)</entry>
          <entry>Fail if $x and $y are the same variable</entry>
        </row>
        <row>
          <entry>assertWantedPattern($p, $x)</entry>
          <entry>Fail unless the regex $p matches $x</entry>
        </row>
        <row>
          <entry>assertNoUnwantedPattern($p, $x)</entry>
          <entry>Fail if the regex $p matches $x</entry>
        </row>
        <row>
          <entry>assertNoErrors()</entry>
          <entry>Fail if any PHP error occoured</entry>
        </row>
        <row>
          <entry>assertError($x)</entry>
          <entry>Fail if no PHP error or incorrect message</entry>
        </row>
        <row>
          <entry>assertErrorPattern($p)</entry>
          <entry>Fail unless the error matches the regex $p</entry> 
        </row>
        </tbody>
      </tgroup>
    </table>
    </para>
    <para>
    All assertion methods can take an optional description to label the displayed result with. If omitted a default message is sent instead which is usually sufficient.
    </para>
    <para>
    Some examples...
    </para>
    <para>
      <programlisting role="php">
      <![CDATA[
$variable = null;
$this->assertNull($variable, 'Should be cleared');
      ]]>
      </programlisting>
    </para>
    <para>
    ...will pass and normally show no message. If you have set up the tester to display passes  as well then the message will be displayed as is.
    </para>
    <para>
      <programlisting role="php">
      <![CDATA[
$this->assertIdentical(0, false, 'Zero is not false [%s]');
      ]]>
      </programlisting>
    </para>
    <para>
    This will fail as it performs a PHP === check between the two values. The "%s" part will be replaced by the default error message that would have been shown if we had not supplied our own. This allows us to nest test messages.
    </para>
    <para>
      <programlisting role="php">
      <![CDATA[
$a = 1;
$b = $a;
$this->assertReference($a, $b);
      ]]>
      </programlisting>
    </para>
    <para>
    Will fail as the variable "$a" is a copy of "$b".
    </para>
    <para>
      <programlisting role="php">
      <![CDATA[
$this->assertWantedPattern('/hello/i', 'Hello world');
      ]]>
      </programlisting>
    </para>
    <para>
    This will pass as using a case insensitive match the string "hello" is contained in "Hello world".
    </para>
    <para>
      <programlisting role="php">
        <![CDATA[
trigger_error('Disaster');
trigger_error('Catastrophe');
$this->assertError();
$this->assertError('Catastrophe');
$this->assertNoErrors();
        ]]>
      </programlisting>
    </para>
    <para>
    This one takes some explanation as in fact they all pass! PHP errors in SimpleTest are trapped and placed in a queue. Here the first error check catches the "Disaster" message without checking the text and passes. This removes the error from the queue. The next error check tests not only the existence of the error, but also the text which here matches so another pass. With the queue now empty the last test will pass as well. If any unchecked errors are left at the end of a test method then an exception will be reported in the test. Note that SimpleTest cannot catch compile time PHP errors.
    </para>
    <para>
    The test cases also have some convenience methods for debugging code or extending the suite...
    </para>
    <table frame="all" id="{@id idtab}">
      <tgroup cols="2">
        <tbody>
        <row>
          <entry>setUp()</entry>
          <entry>Runs this before each test method</entry>
        </row>
        <row>
          <entry>tearDown()</entry>
          <entry>Runs this after each test method</entry>
        </row>
        <row>
          <entry>pass()</entry>
          <entry>Sends a test pass</entry>
        </row>
        <row>
          <entry>fail()</entry>
          <entry>Sends a test failure</entry>
        </row>
        <row>
          <entry>error()</entry>
          <entry>Sends an exception event</entry>
        </row>
        <row>
          <entry>sendMessage()</entry>
          <entry>Sends a status message to those displays that support it</entry>
        </row>
        <row>
          <entry>signal($type, $payload)</entry>
          <entry>Sends a user defined message to the test reporter</entry>
        </row>
        <row>
          <entry>dump($var)</entry>
          <entry>Does a formatted print_r() for quick and dirty debugging</entry>
        </row>
        <row>
          <entry>swallowErrors()</entry>
          <entry>Clears the error queue</entry>
        </row>
        </tbody>
      </tgroup>
    </table>
  </refsect1>
  
  <refsect1 id="{@id extending}">
    <title>Extending test cases</title>
    <para>
    Of course additional test methods can be added to create specific types of test case too so as to extend framework...
    </para>
    <para>
      <programlisting role="php">
      <![CDATA[
if (!defined('SIMPLE_TEST')) {
    define('SIMPLE_TEST', 'path/to/simpletest/');
}
require_once(SIMPLE_TEST . 'unit_tester.php');

class FileTester extends UnitTestCase {
    function FileTester($name = false) {
        $this->UnitTestCase($name);
    }
    function assertFileExists($filename, $message = '%s') {
        $this->assertTrue(
                file_exists($filename),
                sprintf($message, 'File [$filename] existence check'));
    }
}
      ]]>
      </programlisting>
    </para>
    <para>
    The <command>SIMPLE_TEST</command> constant is the path to the SimpleTest libraries and should be set before the first component is called. It is usually set in the top level tests.
    </para>
    <para>
    This new case can be now be inherited just like a normal test case...
    </para>
    <para>
      <programlisting role="php">
      <![CDATA[
class FileTestCase extends FileTester {
    function FileTestCase() {
        $this->FileTester('File test');
    }
    function setUp() {
        @unlink('../temp/test.txt');
    }
    function tearDown() {
        @unlink('../temp/test.txt');
    }
    function testCreation() {
        $writer = &new FileWriter('../temp/test.txt');
        $writer->write('Hello');
        $this->assertFileExists('../temp/test.txt');
    }
}
      ]]>
      </programlisting>
    </para>
    <para>
    If you want a test case that does not have all of the <command>UnitTestCase</command> assertions, only your own and <command>assertTrue()</command>, you need to extend the <command>TestCase</command> class instead. It is found in simple_test.php rather than unit_tester.php. See later if you want to incorporate other unit tester's test cases in your test suites.
    </para>
  </refsect1>

  <refsect1 id="{@id single}">
    <title>Running a single test case</title>
    <para>
    You won't often run single test cases except when bashing away at a module that is having difficulty and you don't want to upset the main test suite. Here is the scaffolding needed to run the a lone test case...
    </para>
    <para>
      <programlisting role="php">
      <![CDATA[
<?php
    if (!defined('SIMPLE_TEST')) {
        define('SIMPLE_TEST', 'path/to/simpletest/');
    }
    require_once(SIMPLE_TEST . 'unit_tester.php');
    require_once(SIMPLE_TEST . 'reporter.php');
    require_once("../classes/writer.php");

    class FileTestCase extends UnitTestCase {
        function FileTestCase() {
            $this->UnitTestCase('File test');
        }
    }
    $test = &new FileTestCase();
    $test->run(new HtmlReporter());
?>
      ]]>
      </programlisting>
    </para>
    <para>
    This script will run as is, but will output zero passes and zero failures until test methods are added.
    </para>
  </refsect1>
  
</refentry>
 



