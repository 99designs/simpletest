<?xml version="1.0" encoding="UTF-8"?>
<refentry id="{@id}">
<refnamediv>
<refname>Web tester</refname>
<refpurpose/>
</refnamediv>
            {@doc}
            
        <refsect1 id="{@id fetch}">
<title>Fetching a page</title>
            <para>
                Testing classes is all very well, but PHP is predominately
                a language for creating functionality within web pages.
                How do we test the front end presentation role of our PHP
                applications?
                Well the web pages are just text, so we should be able to
                examine them just like any other test data.
            </para>
            <para>
                This leads to a tricky issue.
                If we test at too low a level, testing for matching tags
                in the page with pattern matching for example, our tests will
                be brittle.
                The slightest change in layout could break a large number of
                tests.
                If we test at too high a level, say using mock versions of a
                template engine, then we lose the ability to automate some classes
                of test.
                For example, the interaction of forms and navigation will
                have to be tested manually.
                These types of test are extremely repetitive and error prone.
            </para>
            <para>
                SimpleTest includes a special form of test case for the testing
                of web page actions.
                The <span class="new_code">WebTestCase</span> includes facilities
                for navigation, content and cookie checks and form handling.
                Usage of these test cases is similar to the
                <span class="new_code">UnitTestCase</span>...
<program-listing role="php"><![CDATA[
]]><![CDATA[class TestOfLastcraft extends WebTestCase {
    function TestOfLastcraft() {
        $this->WebTestCase();
    }
}]]><![CDATA[
]]></program-listing>
                Here we are about to test the
                <a href="http://www/lastcraft.com/">Last Craft</a> site itself.
                If this test case is in a file called <em>lastcraft_test.php</em>
                then it can be loaded in a runner script just like unit tests...
<program-listing role="php"><![CDATA[
<?php]]><![CDATA[
    require_once('simpletest/web_tester.php');]]><![CDATA[
    require_once('simpletest/reporter.php');
    
    $test = &new GroupTest('Web site tests');]]><![CDATA[
    $test->addTestFile('lastcraft_test.php');]]><![CDATA[
    exit ($test->run(new TextReporter()) ? 0 : 1);
?>
]]></program-listing>
                I am using the text reporter here to more clearly
                distinguish the web content from the test output.
            </para>
            <para>
                Nothing is being tested yet.
                We can fetch the home page by using the
                <span class="new_code">get()</span> method...
<program-listing role="php"><![CDATA[
]]><![CDATA[class TestOfLastcraft extends WebTestCase {
    function TestOfLastcraft() {
        $this->WebTestCase();
    }
    
    function testHomepage() {
        $this->assertTrue($this->get('http://www.lastcraft.com/'));
    }
}]]><![CDATA[
]]></program-listing>
                The <span class="new_code">get()</span> method will
                return true only if page content was successfully
                loaded.
                It is a simple, but crude way to check that a web page
                was actually delivered by the web server.
                However that content may be a 404 response and yet
                our <span class="new_code">get()</span> method will still return true.
            </para>
            <para>
                Assuming that the web server for the Last Craft site is up
                (sadly not always the case), we should see...
<pre class="shell">
Web site tests
OK
Test cases run: 1/1, Failures: 0, Exceptions: 0
</pre>
                All we have really checked is that any kind of page was
                returned.
                We don't yet know if it was the right one.
            </para>
        </refsect1>
        <refsect1 id="{@id content}">
<title>Testing page content</title>
            <para>
                To confirm that the page we think we are on is actually the
                page we are on, we need to verify the page content.
<program-listing role="php"><![CDATA[
class TestOfLastcraft extends WebTestCase {
    ...
    function testHomepage() {]]><![CDATA[
        $this->get('http://www.lastcraft.com/');
        $this->assertWantedPattern('/why the last craft/i');]]><![CDATA[
    }
}
]]></program-listing>
                The page from the last fetch is held in a buffer in
                the test case, so there is no need to refer to it directly.
                The pattern match is always made against the buffer.
            </para>
            <para>
                Here is the list of possible content assertions...
                <table>
                    <tr>
<td>
<span class="new_code">assertWantedPattern($pattern)</span>
</td>
<td>A Perl pattern match against the page content</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertNoUnwantedPattern($pattern)</span>
</td>
<td>A Perl pattern match to not find content</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertTitle($title)</span>
</td>
<td>Pass if title is an exact match</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertLink($label)</span>
</td>
<td>Pass if a link with this text is present</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertNoLink($label)</span>
</td>
<td>Pass if no link with this text is present</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertLinkById($id)</span>
</td>
<td>Pass if a link with this id attribute is present</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertField($name, $value)</span>
</td>
<td>Pass if an input tag with this name has this value</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertFieldById($id, $value)</span>
</td>
<td>Pass if an input tag with this id has this value</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertResponse($codes)</span>
</td>
<td>Pass if HTTP response matches this list</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertMime($types)</span>
</td>
<td>Pass if MIME type is in this list</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertAuthentication($protocol)</span>
</td>
<td>Pass if the current challenge is this protocol</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertNoAuthentication()</span>
</td>
<td>Pass if there is no current challenge</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertRealm($name)</span>
</td>
<td>Pass if the current challenge realm matches</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertHeader($header, $content)</span>
</td>
<td>Pass if a header was fetched matching this value</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertNoUnwantedHeader($header)</span>
</td>
<td>Pass if a header was not fetched</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertHeaderPattern($header, $pattern)</span>
</td>
<td>Pass if a header was fetched matching this Perl regex</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertCookie($name, $value)</span>
</td>
<td>Pass if there is currently a matching cookie</td>
</tr>
                    <tr>
<td>
<span class="new_code">assertNoCookie($name)</span>
</td>
<td>Pass if there is currently no cookie of this name</td>
</tr>
                </table>
                As usual with the SimpleTest assertions, they all return
                false on failure and true on pass.
                They also allow an optional test message and you can embed
                the original test message inside using "%s" inside
                your custom message.
            </para>
            <para>
                So now we could instead test against the title tag with...
<program-listing role="php"><![CDATA[
]]><![CDATA[$this->assertTitle('The Last Craft?');]]><![CDATA[
]]></program-listing>
                As well as the simple HTML content checks we can check
                that the MIME type is in a list of allowed types with...
<program-listing role="php"><![CDATA[
]]><![CDATA[$this->assertMime(array('text/plain', 'text/html'));]]><![CDATA[
]]></program-listing>
                More interesting is checking the HTTP response code.
                Like the MIME type, we can assert that the response code
                is in a list of allowed values...
<program-listing role="php"><![CDATA[
class TestOfLastcraft extends WebTestCase {
    ...
    function testHomepage() {
        $this->get('http://simpletest.sourceforge.net/');]]><![CDATA[
        $this->assertResponse(200);]]><![CDATA[
    }
}
]]></program-listing>
                Here we are checking that the fetch is successful by
                allowing only a 200 HTTP response.
                This test will pass, but it is not actually correct to do so.
                There is no page for <em>http://simpletest.sourceforge.net/</em>,
                instead the server issues a redirect to
                <em>http://www.lastcraft.com/simple_test.php</em>.
                The <span class="new_code">WebTestCase</span> will
                automatically follow up to three such redirects.
                The tests are more robust this way and we are usually
                interested in the interaction with the pages rather
                than their delivery.
                If the redirects are of interest then this ability must
                be disabled...
<program-listing role="php"><![CDATA[
class TestOfLastcraft extends WebTestCase {
    ...
    function testHomepage() {]]><![CDATA[
        $this->setMaximumRedirects(0);]]><![CDATA[
        $this->get('http://simpletest.sourceforge.net/');
        $this->assertResponse(200);
    }
}
]]></program-listing>
                The assertion now fails as expected...
<pre class="shell">
Web site tests
1) Expecting response in [200] got [302]
	in testhomepage
	in testoflastcraft
	in lastcraft_test.php
FAILURES!!!
Test cases run: 1/1, Failures: 1, Exceptions: 0
</pre>
                We can modify the test to correctly assert redirects with...
<program-listing role="php"><![CDATA[
class TestOfLastcraft extends WebTestCase {
    ...
    function testHomepage() {
        $this->setMaximumRedirects(0);
        $this->get('http://simpletest.sourceforge.net/');
        $this->assertResponse(]]><![CDATA[array(301, 302, 303, 307)]]><![CDATA[);
    }
}
]]></program-listing>
                This now passes.
            </para>
        </refsect1>
        <refsect1 id="{@id navigation}">
<title>Navigating a web site</title>
            <para>
                Users don't often navigate sites by typing in URLs, but by
                clicking links and buttons.
                Here we confirm that the contact details can be reached
                from the home page...
<program-listing role="php"><![CDATA[
class TestOfLastcraft extends WebTestCase {
    ...
    function testContact() {
        $this->get('http://www.lastcraft.com/');]]><![CDATA[
        $this->clickLink('About');
        $this->assertTitle('About Last Craft');]]><![CDATA[
    }
}
]]></program-listing>
                The parameter is the text of the link.
            </para>
            <para>
                If the target is a button rather than an anchor tag, then
                <span class="new_code">clickSubmit()</span> should be used
                with the button title...
<program-listing role="php"><![CDATA[
]]><![CDATA[$this->clickSubmit('Go!');]]><![CDATA[
]]></program-listing>
            </para>
            <para>
                The list of navigation methods is...
                <table>
                    <tr>
<td>
<span class="new_code">get($url, $parameters)</span>
</td>
<td>Send a GET request with these parameters</td>
</tr>
                    <tr>
<td>
<span class="new_code">post($url, $parameters)</span>
</td>
<td>Send a POST request with these parameters</td>
</tr>
                    <tr>
<td>
<span class="new_code">head($url, $parameters)</span>
</td>
<td>Send a HEAD request without replacing the page content</td>
</tr>
                    <tr>
<td>
<span class="new_code">retry()</span>
</td>
<td>Reload the last request</td>
</tr>
                    <tr>
<td>
<span class="new_code">back()</span>
</td>
<td>Like the browser back button</td>
</tr>
                    <tr>
<td>
<span class="new_code">forward()</span>
</td>
<td>Like the browser forward button</td>
</tr>
                    <tr>
<td>
<span class="new_code">authenticate($name, $password)</span>
</td>
<td>Retry after a challenge</td>
</tr>
                    <tr>
<td>
<span class="new_code">getFrameFocus()</span>
</td>
<td>The name of the currently selected frame</td>
</tr>
                    <tr>
<td>
<span class="new_code">setFrameFocusByIndex($choice)</span>
</td>
<td>Focus on a frame counting from 1</td>
</tr>
                    <tr>
<td>
<span class="new_code">setFrameFocus($name)</span>
</td>
<td>Focus on a frame by name</td>
</tr>
                    <tr>
<td>
<span class="new_code">clearFrameFocus()</span>
</td>
<td>Go back to treating all frames as one page</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickSubmit($label)</span>
</td>
<td>Click the first button with this label</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickSubmitByName($name)</span>
</td>
<td>Click the button with this name attribute</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickSubmitById($id)</span>
</td>
<td>Click the button with this ID attribute</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickImage($label, $x, $y)</span>
</td>
<td>Click an input tag of type image by title or alt text</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickImageByName($name, $x, $y)</span>
</td>
<td>Click an input tag of type image by name</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickImageById($id, $x, $y)</span>
</td>
<td>Click an input tag of type image by ID attribute</td>
</tr>
                    <tr>
<td>
<span class="new_code">submitFormById($id)</span>
</td>
<td>Submit a form without the submit value</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickLink($label, $index)</span>
</td>
<td>Click an anchor by the visible label text</td>
</tr>
                    <tr>
<td>
<span class="new_code">clickLinkById($id)</span>
</td>
<td>Click an anchor by the ID attribute</td>
</tr>
                </table>
            </para>
            <para>
                The parameters in the <span class="new_code">get()</span>, <span class="new_code">post()</span> or
                <span class="new_code">head()</span> methods are optional.
                The HTTP HEAD fetch does not change the browser context, only loads
                cookies.
                This can be useful for when an image or stylesheet sets a cookie
                for crafty robot blocking.
            </para>
            <para>
                The <span class="new_code">retry()</span>, <span class="new_code">back()</span> and
                <span class="new_code">forward()</span> commands work as they would on
                your web browser.
                They use the history to retry pages.
                This can be handy for checking the effect of hitting the
                back button on your forms.
            </para>
            <para>
                The frame methods need a little explanation.
                By default a framed page is treated just like any other.
                Content will be searced for throughout the entire frameset,
                so clicking a link will work no matter which frame
                the anchor tag is in.
                You can override this behaviour by focusing on a single
                frame.
                If you do that, all searches and actions will apply to that
                frame alone, such as authentication and retries.
                If a link or button is not in a focused frame then it cannot
                be clicked.
            </para>
            <para>
                Testing navigation on fixed pages only tells you when you
                have broken an entire script.
                For highly dynamic pages, such as for bulletin boards, this can
                be crucial for verifying the correctness of the application.
                For most applications though, the really tricky logic is usually in
                the handling of forms and sessions.
                Fortunately SimpleTest includes
                <a href="form_testing_documentation.html">tools for testing web forms</a>
                as well.
            </para>
        </refsect1>
        <refsect1 id="{@id request}">
<title>Modifying the request</title>
            <para>
                Although SimpleTest does not have the goal of testing networking
                problems, it does include some methods to modify and debug
                the requests it makes.
                Here is another method list...
                <table>
                    <tr>
<td>
<span class="new_code">getTransportError()</span>
</td>
<td>The last socket error</td>
</tr>
                    <tr>
<td>
<span class="new_code">getUrl()</span>
</td>
<td>The current location</td>
</tr>
                    <tr>
<td>
<span class="new_code">showRequest()</span>
</td>
<td>Dump the outgoing request</td>
</tr>
                    <tr>
<td>
<span class="new_code">showHeaders()</span>
</td>
<td>Dump the incoming headers</td>
</tr>
                    <tr>
<td>
<span class="new_code">showSource()</span>
</td>
<td>Dump the raw HTML page content</td>
</tr>
                    <tr>
<td>
<span class="new_code">ignoreFrames()</span>
</td>
<td>Do not load framesets</td>
</tr>
                    <tr>
<td>
<span class="new_code">setCookie($name, $value)</span>
</td>
<td>Set a cookie from now on</td>
</tr>
                    <tr>
<td>
<span class="new_code">addHeader($header)</span>
</td>
<td>Always add this header to the request</td>
</tr>
                    <tr>
<td>
<span class="new_code">setMaximumRedirects($max)</span>
</td>
<td>Stop after this many redirects</td>
</tr>
                    <tr>
<td>
<span class="new_code">setConnectionTimeout($timeout)</span>
</td>
<td>Kill the connection after this time between bytes</td>
</tr>
                    <tr>
<td>
<span class="new_code">useProxy($proxy, $name, $password)</span>
</td>
<td>Make requests via this proxy URL</td>
</tr>
                </table>
            </para>
        </refsect1>
    </refentry>
