<refentry id="{@id}">
  <refnamediv>
    <refname>Server Stubs</refname>
    <refpurpose>A server stub is a simulation of an object or component.  This page covers how to create and use Server Stubs in SimpleTest.</refpurpose>
  </refnamediv>
  {@toc}
  
  <refsect1 id="{@id what}">
    <title>What are Server Stubs?</title>
    <para> This was originally a pattern named by Robert Binder (Testing object-oriented systems: models, patterns, and tools, Addison-Wesley) in 1999. A server stub is a simulation of an object or component. It should exactly replace a component in a system for test or prototyping purposes, but remain lightweight. This allows tests to run more quickly, or if the simulated class has not been written, to run at all.</para>
  </refsect1>

  <refsect1 id="{@id create}">
    <title>Creating Server Stubs</title>
    <para>
    All we need is an existing class, say a database connection that looks like this...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
class DatabaseConnection {
    function DatabaseConnection() {
    }
    function query() {
    }
    function selectQuery() {
    }
}
      ]]>
      </programlisting>
    </para>
    <para>
    The class does not need to have been implemented yet. To create a stub version of the class we need to include the server stub library and run the generator...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
if (!defined('SIMPLE_TEST')) {
    define('SIMPLE_TEST', 'simpletest/');
}
require_once(SIMPLE_TEST . 'mock_objects.php');
require_once('database_connection.php');
Stub::generate('DatabaseConnection');
      ]]>
      </programlisting>
    </para>
    <para>
    This generates a clone class called <command>StubDatabaseConnection</command>. We can now create instances of the new class within our prototype script...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
if (!defined('SIMPLE_TEST')) {
    define('SIMPLE_TEST', 'simpletest/');
}
require_once(SIMPLE_TEST . 'mock_objects.php');
require_once('database_connection.php');
Stub::generate('DatabaseConnection');
$connection = new StubDatabaseConnection();
      ]]>
      </programlisting>
    </para>
    <para>
    The stub version of a class has all the methods of the original so that operations like <command>$connection->query()</command> are still legal. The return value will be <command>null</command>, but we can change that with...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
$connection->setReturnValue('query', 37)
      ]]>
      </programlisting>
    </para>
    <para>
    Now every time we call <command>$connection->query()</command> we get the result of 37. We can set the return value to anything, say a hash of imaginary database results or a list of persistent objects. Parameters are irrelevant here, we always get the same values back each time once they have been set up this way. That may not sound like a convincing replica of a database connection, but for the half a dozen lines of a test method it is usually all you need.
    </para>
  </refsect1>

  <refsect1 id="{@id simpat}">
    <title>Simulation Patterns</title>
    <para>
    Things aren't always that simple though. One common problem is iterators, where constantly returning the same value could cause an endless loop in the object being tested. For these we need to set up sequences of values. Let's say we have a simple iterator that looks like this...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
class Iterator {
    function Iterator() {
    }
    function next() {
    }
}
      ]]>
      </programlisting>
    </para>
    <para>
    This is about the simplest iterator you could have. Assuming that this iterator only returns text until it reaches the end, when it returns false, we can simulate it with...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
Stub::generate('Iterator');

$iterator = new StubIterator();
$iterator->setReturnValue('next', false);
$iterator->setReturnValueAt(0, 'next', 'First string');
$iterator->setReturnValueAt(1, 'next', 'Second string');
      ]]>
      </programlisting>
    </para>
    <para>
    When <command>next()</command> is called on the stub iterator it will first return "First string", on the second call "Second string" will be returned and on any other call <command>false</command> will be returned. The sequenced return values take precedence over the constant return value. The constant one is a kind of default if you like.
    </para>
    <para>
    Another tricky situation is an overloaded <command>get()</command> operation. An example of this is an information holder with name/value pairs. Say we have a configuration class like...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
class Configuration {
    function Configuration() {
    }
    function getValue($key) {
    }
}
      ]]>
      </programlisting>
    </para>
    <para>
    This is a classic situation for using stub objects as actual configuration will vary from machine to machine, hardly helping the reliability of our tests if we use it directly. The problem though is that all the data comes through the <command>getValue()</command> method and yet we want different results for different keys. Luckily the stubs have a filter system...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
Stub::generate('Configuration');

$config = new StubConfiguration();
$config->setReturnValue('getValue', 'primary', array('db_host'));
$config->setReturnValue('getValue', 'admin', array('db_user'));
$config->setReturnValue('getValue', 'secret', array('db_password'));
      ]]>
      </programlisting>
    </para>
    <para>
    The extra parameter is a list of arguments to attempt to match. In this case we are trying to match only one argument which is the look up key. Now when the server stub has the <command>getValue()</command> method invoked like this...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
$config->getValue('db_user');
      ]]>
      </programlisting>
    </para>
    <para>
    ...it will return "admin". It finds this by attempting to match the calling arguments to it's list of returns one after another until a complete match is found.
    </para>
    <para>
    You can set a default argument argument like so...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
$config->setReturnValue('getValue', false, array('*'));
      ]]>
      </programlisting>
    </para>
    <para>
    This is not the same as setting the return value without any argument requirements like this...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
$config->setReturnValue('getValue', false);
      ]]>
      </programlisting>
    </para>
    <para>
    In the first case it will accept any single argument, but exactly one is required. In the second case any number of arguments will do and it acts as a catchall after all other matches. Note that if we add further single parameter options after the wildcard in the first case, they will be ignored as the wildcard will match first. With complex parameter lists the ordering could be important or else desired matches could be masked by earlier wildcard ones. Declare the most specific matches first if you are not sure.
    </para>
    <para>
    There are times when you want a specific object to be dished out by the stub rather than just a copy. The PHP copy semantics force us to use a different method for this. You might be simulating a container for example...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
class Thing {
}

class Vector {
    function Vector() {
    }
    function get($index) {
    }
}
      ]]>
      </programlisting>
    </para>
    <para>
    In this case you can set a reference into the stub's return list...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
Stub::generate('Vector');

$thing = new Thing();
$vector = &new StubVector();
$vector->setReturnReference('get', $thing, array(12));
      ]]>
      </programlisting>
    </para>
    <para>
    With this arrangement you know that every time <command>$vector->get(12)</command> is called it will return the same <command>$thing</command> each time.
    </para>
    <para>
    These three factors, timing, parameters and whether to copy, can be combined orthogonally. For example...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
$complex = &new StubComplexThing();
$stuff = new Stuff();
$complex->setReturnReferenceAt(3, 'get', $stuff, array('*', 1));
      ]]>
      </programlisting>
    </para>
    <para>
    This will return the $stuff only on the third call and only if two parameters were set the second of which must be the integer 1. That should cover most simple prototyping situations.
    </para>
    <para>
    A final tricky case is one object creating another, known as a factory pattern. Suppose that on a successful query to our imaginary database, a result set is returned as an iterator with each call to next() giving one row until false. This sounds like a simulation nightmare, but in fact it can all be stubbed using the mechanics above.
    </para>
    <para>
    Here's how...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
Stub::generate('DatabaseConnection');
Stub::generate('ResultIterator');

class DatabaseTest extends UnitTestCase {
    function DatabaseTest() {
        $this->UnitTestCase();
    }
    function testUserFinder() {
        $result = &new StubResultIterator();
        $result->setReturnValue('next', false);
        $result->setReturnValueAt(0, 'next', array(1, 'tom'));
        $result->setReturnValueAt(1, 'next', array(3, 'dick'));
        $result->setReturnValueAt(2, 'next', array(6, 'harry'));
        $connection = &new StubDatabaseConnection();
        $connection->setReturnValue('query', false);
        $connection->setReturnReference(
                'query',
                $result,
                array('select id, name from users'));
        $finder = &new UserFinder($connection);
        $this->assertIdentical(
                $finder->findNames(),
                array('tom', 'dick', 'harry'));
    }
}
      ]]>
      </programlisting>
    </para>
    <para>
    Now only if our <command>$connection</command> is called with the correct <command>query()</command> will the <command>$result</command> be returned that is itself exhausted after the third call to <command>next()</command>. This should be enough information for our <command>UserFinder</command> class, the class actually being tested here, to come up with goods. A very precise test and not a real database in sight.
    </para>
  </refsect1>

  <refsect1 id="{@id stubopt}">
    <title>Stub Creation Options</title>
    <para>
    There are some additional options when creating stubs. At the generation stage we can change the class name...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
Stub::generate('Iterator', 'MyStubIterator');
$iterator = new MyStubIterator();
      ]]>
      </programlisting>
    </para>
    <para>
    This is not very useful in itself as there would be no difference in this class and the default except for the name. However we can also add additional methods not found in the original interface...
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
class Iterator {
}
Stub::generate('Iterator', 'PrototypeIterator', array('next', 'isError'));
$iterator = new PrototypeIterator();
$iterator->setReturnValue('next', 0);
      ]]>
      </programlisting>
    </para>
    <para>
    The <command>next()</command> and <command>isError()</command> methods can now have return values set just as if they existed in the original class.
    </para>
    <para>
    One other esoteric way of customising the stubs is to change the default wildcard used for parameter matching.
    </para>
    <para>
     <programlisting role="php">
      <![CDATA[
Stub::generate('Connection');
$iterator = new StubConnection('wild');
$iterator->setReturnValue('query', array('id' => 33), array('wild'));
      ]]>
      </programlisting>
    </para>
    <para>
    The only reason to do this is if you genuinely wanted to test against the literal string "*" and didn't want it interpreted as "any".
    </para>
  </refsect1>
  
</refentry>
