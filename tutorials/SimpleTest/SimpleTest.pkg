<refentry id="{@id}">
  <refnamediv>
    <refname>Simple Test PHP Unit Test Framework</refname>
    <refpurpose></refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <authorgroup>
    <author>
    Marcus Baker
    <authorblurb>
      <para>Primary Developer</para><para>{@link mailto:marcus@lastcraft.com marcus@lastcraft.com}</para>
    </authorblurb>
    </author>
    <author>
    Harry Fuecks
    <authorblurb>
      <para>Packager</para><para>{@link mailto:harryf@users.sourceforge.net harryf@users.sourceforge.net}</para>
    </authorblurb>
    </author>
    <author>
    Jason Sweat
    <authorblurb>
      <para>Documentation</para><para>{@link mailto:jsweat_php@yahoo.com jsweat_php@yahoo.com}</para>
    </authorblurb>
    </author>
    </authorgroup>
  </refsynopsisdiv>
  {@toc}
  <refsect1 id="{@id usage}">
    <title>Simple Test</title>
    <para>The heart of SimpleTest is a testing framework built around test case classes. These are written as extensions of base test case classes, each extended with methods that actually contain test code. Top level test scripts then invoke the <command>run()</command>  methods on every one of these test cases in order. Each test method is written to invoke various assertions that the developer expects to be true such as <command>assertEqual()</command>. If the expectation is correct, then a successful result is dispatched to the observing test reporter, but any failure triggers an alert and a description of the mismatch.</para>
  </refsect1>
  <refsect1 id="{@id testcase}">
    <title>Unit Test Case</title>
    <para>A test case looks like this...</para>
    <para>
     <programlisting role="php">
     <![CDATA[
class MyTestCase extends UnitTestCase {
    function MyTestCase() {
        $this->UnitTestCase();
    }
    function testLog() {
        $log = new Log("my.log");
        $log->message("Hello");
        $this->assertTrue(file_exists("my.log"));
    }
}
     ]]>
     </programlisting>
    </para>
    <para>
    These tools are designed for the developer. Tests are written in the PHP language itself more or less as the application itself is built. The advantage of using PHP itself as the testing language is that there are no new languages to learn, testing can start straight away, and the developer can test any part of the code. Basically, all parts that can be accessed by the application code can also be accessed by the test code if they are in the same language.
    </para>
    <para>
    The simplest type of test case is the <command>UnitTestCase</command>. This class of test case includes standard tests for equality, references and pattern matching. All these test the typical expectations of what you would expect the result of a function or method to be. This is by far the most common type of test in the daily routine of development, making up about 95% of test cases.
    </para>
  </refsect1>
  <refsect1 id="{@id webtestcase}">
    <title>Web Test Case</title>
    <para>
    The top level task of a web application though is not to produce correct output from it's methods and objects, but to generate web pages. The <command>WebTestCase</command> class tests web pages. It simulates a web browser requesting a page, complete with cookies and GET/POST parameters. With this type of test case, the developer can assert that information is present in the page and that forms and sessions are handled correctly.
    </para>
    <para>A web test case looks like this...</para>
    <para>
     <programlisting role="php">
     <![CDATA[
class MySiteTest extends WebTestCase {
    function MySiteTest() {
        $this->WebTestCase();
    }
    function testHomePage() {
        $this->get("http://www.my-site.com/index.php");
        $this->assertTitle("My Home Page");
        $this->clickLink("Contact");
        $this->assertTitle("Contact me");
        $this->assertWantedPattern("/Email me at/");
    }
}
     ]]>
     </programlisting>
    </para>
  </refsect1>
  <refsect1 id="{@id features}">
    <title>Features</title>
    <para>
    SimpleTest has a monthly release cycle. The following is a very rough outline of upcoming features and their expected point of release. I am afraid it is liable to change without warning as meeting the milestones rather depends on time available. Green stuff has been coded, but not necessarily released yet. If you have a pressing need for a green but unreleased feature then you should check-out the code from sourceforge CVS directly.
    </para>
    <table frame="all" id="{@id featuretab}">
    <tgroup cols="3">
      <thead align="center">
        <row>
          <entry>Feature</entry>
          <entry>Description</entry>
          <entry>Release</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>Unit test case</entry>
          <entry>Core test case class and assertions</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Html display</entry>
          <entry>Simplest possible display</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Autoloading of test cases</entry>
          <entry>Reading a file with test cases and loading them into a group test automatically</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Mock objects code generator</entry>
          <entry>Objects capable of simulating other objects removing test dependencies</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Server stubs</entry>
          <entry>Mocks without expectations to be used outside of test cases, e.g. for prototyping</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Integration of other unit testers</entry>
          <entry>The ability to read and simulate test cases from PHPUnit and PEAR::PhpUnit</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Web test case</entry>
          <entry>Basic pattern matching of fetched pages</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>HTML parsing of pages</entry>
          <entry>Allows link following and title tag matching</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Partial mocks</entry>
          <entry>Mocking parts of a class for testing less than a class or for complex simulations</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Web cookie handling</entry>
          <entry>Correct handling of cookies when fetching pages</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Following redirects</entry>
          <entry>Page fetching automatically follows 300 redirects</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Form parsing</entry>
          <entry>Ability to submit simple forms and read default form values</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Command line interface</entry>
          <entry>Test display without the need of a web browser</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Exposure of expectation classes</entry>
          <entry>Can create precise tests with mocks as well as test cases</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>XML output and parsing</entry>
          <entry>Allows multi host testing and the integration of acceptance testinG extensions</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Command line test case</entry>
          <entry>Allows testing of utilities and file handling</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>PHP Documentor compatibility</entry>
          <entry>Ability to generate class level documentation</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Browser interface</entry>
          <entry>Exposure of lower level web browser interface for more detailed test cases</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>HTTP authentication</entry>
          <entry>
		    Fetching protected web pages with basic authentication
   	        only
          </entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Browser navigation buttons</entry>
          <entry>Back, forward and retry</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>SSL support</entry>
          <entry>Can connect to https: pages</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Proxy support</entry>
          <entry>Can connect via. common proxies</entry>
          <entry class="done">Done</entry>
        </row>
        <row>
          <entry>Frames support</entry>
          <entry>Handling of frames in web test cases</entry>
          <entry class="upnext">1.0</entry>
        </row>
        <row>
          <entry>Improved display</entry>
          <entry>Better web GUI with tree display of test cases</entry>
          <entry class="upnext">1.1</entry>
        </row>
        <row>
          <entry>Localisation</entry>
          <entry>Messages abstracted and code generated from XML</entry>
          <entry class="upnext">1.1</entry>
        </row>
      </tbody>
    </tgroup>
  </table>
  <para>
  A PHP5 version will be released once PHP5 is broadly available.
  Simpletest is currently compatible with PHP5, but does not make use of all of the new features.
  </para>
  <para>
  The wish list includes integration with other test systems including JUnit and XsltUnit, an eclipse plug-in, SOAP testing and HTTP 1.1 support. In reality I doubt these will ever happen.
  </para>
  </refsect1>

  <refsect1 id="{@id webresource}">
    <title>Web resources for testing</title>
    <para>
    Process is at least as important as tools. The type of process that makes the heaviest use of a developer's testing tool is of course {@link http://www.extremeprogramming.org/ Extreme Programming}. This is one of the {@link http://www.agilealliance.com/articles/index Agile Methodologies} which combine various practices to "flatten the cost curve" of software development. More extreme still is {@link http://www.testdriven.com/modules/news/ Test Driven Development}, where you very strictly adhere to the rule of no coding until you have a test. If your more of a planner or believe that experience trumps evolution, you may prefer the {@link http://www.therationaledge.com/content/dec_01/f_spiritOfTheRUP_pk.html RUP} approach. I haven't tried it, but even I can see that you will need test tools (see figure 9). Better yet, combine them into {@link http://www.objectmentor.com/publications/RUPvsXP.pdf dX} and then turn your head upside down. 
    </para>
    <para>
    Most unit testers clone {@link http://www.junit.org/ JUnit} to some degree, as far as the interface at least. There is a wealth of information on the JUnit site including the {@link http://junit.sourceforge.net/doc/faq/faq.htm FAQ}  which contains plenty of general advice on testing. Once you get bitten by the bug you will certainly appreciate the phrase {@link http://junit.sourceforge.net/doc/testinfected/testing.htm test infected} coined by Eric Gamma. If you are still reviewing which unit tester to use the main choices are {@link http://phpunit.sourceforge.net/ PHPUnit} and {@link http://pear.php.net/manual/en/package.php.phpunit.php Pear PHP::PHPUnit}. They currently lack a lot of features found in {@link http://simpletest.sourceforge.net/ SimpleTest}, but the PEAR version at least is due for a major upgrade for PHP5.
    </para>
    <para>
    Library writers don't seem to ship tests with their code very often which is a shame. Library code that includes tests can be more safely refactored and the test code can act as additional documentation in a fairly standard form. This can save trawling the source code for clues when problems occour, especially when upgrading such a library. If you are hunting for testing examples in PHP libraries then there are a few exceptions. The {@link http://ismo.sourceforge.net/ ISMO library for PHP} uses the PEAR unit tester and also includes a clever trick for mocking PHP functions. Libraries using SimpleTest for their unit testing include {@link http://wact.sourceforge.net/ WACT} and {@link http://sourceforge.net/projects/htmlsax PEAR::XML_HTMLSax}.
    </para>
    <para>
    There is currently a sad lack of material on mock objects, which is a shame as unit testing without them is a lot more work. The {@link http://www.sidewize.com/company/mockobjects.pdf original mock objects paper} is very Java focused, but still worth a read. As a new technology there are plenty of discussions and debate on how to use mocks, often on Wikis such as {@link http://xpdeveloper.com/cgi-bin/oldwiki.cgi?MockObjects Extreme Tuesday} or {@link http://www.mockobjects.com/wiki/MocksObjectsPaper www.mockobjects.com} or {@link http://c2.com/cgi/wiki?MockObject the original C2 Wiki}. Injecting mocks into a class is the main area of debate for which this {@link http://www-106.ibm.com/developerworks/java/library/j-mocktest.html paper on IBM} makes a good starting point.
    </para>
    <para>
    There are plenty of web testing tools, but most are written in Java and tutorials and advice are rather thin on the ground. The only hope is to look at the documentation for {@link http://httpunit.sourceforge.net/ HTTPUnit}, {@link http://htmlunit.sourceforge.net/ HTMLUnit} or {@link http://jwebunit.sourceforge.net/ JWebUnit} and hope for clues. One interesting alternative is {@link http://www.incanica.com/itp.html ITP}. This framework uses XML to write the test cases, which is handy if your Java knowledge is limited (like mine). It still needs Java to run.
    </para>
  </refsect1>

  <refsect1 id="{@id webresource}">
    <title>Additional resources for testing</title>
    <para>
    For coarse benchmarking you can use <command>ab</command>, the Apache Benchmark, or a number of other {@link http://jakarta.apache.org/ Jakarta} testing tools. Apart from <command>ab</command>, you will probably have to have Java(tm) installed to use these alternatives. If you are not using Apache then you will have to read through your web server documentation or find a way to run your scripts from the command line to time them. End to end page timings are a very effective return on the time spent optimising. Once a page appears to be slow, breaking down the task timings to find bottlenecks can be a real challenge.
    </para>
    <para>
    For fine profiling of the PHP code base itself there are two alternatives, although both have install issues. The first is {@link http://pear.php.net/package/apd apd} (advanced PHP debugger) from the PEAR stable. The profiler comes as part of this debugging tool, but can be very slow to process the gathered data. The alternative {@link http://www.xdebug.org/ XDebug} comes highly recommended, but I have not tried this tool.
    </para>
    <para>
    One very useful source of information though is you.
    </para>
    <para>
    Yes, that's right, you!
    </para>
    <para>
    Almost everything you discover in the PHP testing field will be pretty new even if perhaps it was also recently disovered by somebody else. If you have an opinion on fine grain testing of web applications, I would {@link mailto:marcus@lastcraft.com love to hear from you} and so would everyone else. Together we can grope towards better practices and coach newcomers up to our self imposed coding standard - the one that says the code must at least work. I'll happily place any accumulated wisdom in {@link http://www.lastcraft.com/ lastcraft} manually until I can start a Blog, and I will of course credit you with suggestions. Even better, post suggestions on the popular PHP forums and spread the test infection far and wide. 
    </para>
    <para>
    On the other hand if you want a particular feature added I can probably oblige or at least provide a work around. You just have to ask. If you are just having problems, feel free to contact me as well. I will usually answer support queries within a couple of days and I am building a FAQ, so all questions will be entertained. Even if you consider them silly, others will be eternally grateful.
    </para>
    <para>
    Oh yes, and thanks for reading this far. 
    </para>
  </refsect1>
</refentry>